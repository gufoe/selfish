


use std::net::{TcpStream};


use com::TcpWrapper;


use std::thread;

// use tarpc::future::client::ClientExt;
// use tarpc::util::FirstSocketAddr;
use getopts::Matches;
use hashbrown::HashMap;

use rpc;
use net;
use ga;
use util;
use util::gmut;
use dataset;
use storage;
use fitness::eval_net;
use dataset::Dataset;
// use rpc::supahot::*;


pub fn client(args: Matches, mut ds: Dataset) {

    let thread_num = util::arg(&args, "threads", 1);
    let addr = util::arg(&args, "connect", "127.0.0.1:54321".to_string());

    let mut net_defs = HashMap::new();

    let mut bdef_in = vec![];
    let mut bdef_out = vec![];
    for i in 0..28 {
        for j in 0..28 {
            bdef_in.push(format!("!in {}-{}", i, j));
        }
    }
    for i in 0..10 {
        bdef_out.push(format!("!out {}", i));
    }
    net_defs.insert("main_net".to_string(), ("main_net".to_string(), bdef_in, bdef_out)); // main_net

    ds.mode = dataset::DsMode::Train;
    let train_ds = ds.clone();
    ds.mode = dataset::DsMode::Val;
    let val_ds = ds.clone();
    let net_defs = net_defs.clone();
    let nets: Vec<rpc::NetDescription> = net_defs.values().map(|x|x.clone()).collect();




    let mut threads = vec![];
    for _ in 0..thread_num {
        let addr = addr.clone();
        let nets = nets.clone();
        let train_ds = train_ds.clone();
        let val_ds = val_ds.clone();
        let net_defs = net_defs.clone();

        threads.push(thread::spawn(move || {
            match TcpStream::connect(addr) {
                Ok(stream) => {
                    handle_client(TcpWrapper {stream}, nets, train_ds, val_ds, net_defs);
                },
                Err(e) => {
                    eprintln!("[c] Failed to connect: {}", e);
                }
            }
        }));
    }

    for t in threads {
        t.join().expect("Cannot join thread");
    }

}



pub fn test_best(file: &String, mut ds: Dataset) {
    ds.mode = dataset::DsMode::Test;
    let mut best: HashMap<String, net::Net> = storage::load_leaders(file);
    // let mut net_base = best["base"].clone();
    // let mut net_ctrl = best["ctrl"].clone();
    eval_net(&mut best, &ds, &(0..ds.len()).collect(), 0, true);
    println!("Score is: {}", best["main_net"].score);
}




fn handle_client(mut com: TcpWrapper, nets:  Vec<rpc::NetDescription>, train_ds: Dataset, val_ds: Dataset, net_defs: HashMap<String, (String, Vec<String>, Vec<String>)>) {
    let th: usize = 0;
    println!("new client!!");
    // new_stub is generated by the service! macro. Like Server, it takes a config and any
    // Transport as input, and returns a Client, also generated by the macro.
    // by the service mcro.
    // let mut client = await!(service::new_stub(client::Config::default(), transport))?;


    eprintln!("[c {}] Getting net...", th);
    let (mut rec_nets, mut opts): (HashMap<String, Vec<net::Net>>, rpc::Opts) = com.ask(&rpc::Cmd::Get(nets.clone()));

    loop {
        let mut gaps: HashMap<String, ga::GA> = HashMap::new();
        for (name, _nets) in rec_nets.iter() {
            gaps.insert(name.to_string(), ga::GA::new());
            gmut(&mut gaps, name).lead_size = opts.lead_size;
        }


        // The smaller trainset
        let mut trainset = vec![];
        for _i in 0..opts.tset_slice {
            // trainset.push(_i)
            trainset.push(util::rand_int(train_ds.len() as u32) as usize)
        }

        // The bigger trainset
        let mut valset = vec![];
        for _i in 0..opts.vset_slice {
            // valset.push(_i)
            valset.push(util::rand_int(val_ds.len() as u32) as usize)
        }

        // eprintln!("samples: {}", opts.samples);
        let mut tested = vec![];
        let _perf = util::time();
        let mut tot_score = 0.;
        for i in 0..opts.samples as usize {
            let mut nns = HashMap::new();
            for (name, nets) in rec_nets.iter() {
                let net_def = &net_defs[&name.to_string()];

                let mut net = if i < nets.len() {
                    nets[i].clone()
                } else {
                    let mut net = net::Net::from_ga(&mut gmut(&mut gaps, &name), &net_def.1, &net_def.2);
                    net.vset = nets[0].vset;
                    net
                };

                debug!("[c {}] Mutating [{}]...", th, i);
                // net.mutate(&gmut(&mut gaps, name), opts.mrate);
                net.mutate(&gmut(&mut gaps, name), opts.mrate);

                // net.clean(&net_def.1);
                nns.insert(name.to_string(), net);
            }


            let score = eval_net(&mut nns, &train_ds, &trainset, 0, false);
            tot_score+= score;

            for (name, mut net) in nns.iter_mut() {
                // eprintln!("Recording net...");
                gmut(&mut gaps, &name).record(&mut net);
            }

            tested.push((score, nns));
        }

        let test_time = _perf.diff_milli();


        // Use the first test and label set
        tested.sort_by(|a, b| a.0.partial_cmp(&b.0).expect("cannot order u0s98da"));
        let len = tested.len();
        let mut best = tested.remove(len-1);

        let val_score = eval_net(&mut best.1, &val_ds, &valset, 0, false);

        // debug!("[c {}] Sending evaluation  {}...", th, final_score);
        let _perf = util::time();

        let rec: (HashMap<String, Vec<net::Net>>, rpc::Opts) = com.ask(&rpc::Cmd::RecordAndGet(best.1, nets.clone()));
        rec_nets = rec.0;
        opts = rec.1;
        println!("{}", format!("[c {}] f={} s={} t={: >4.2} at={: >4.2} as={: >3.6} rec={: >4.2}...", th, val_score, opts.samples, test_time, test_time/opts.samples as f32, tot_score/opts.samples as f32, _perf.diff_milli()));
    }
}
